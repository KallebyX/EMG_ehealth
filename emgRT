import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.graph_objs as go
import serial
import numpy as np
from scipy.signal import butter, filtfilt, iirnotch

# Configuração da porta serial
port = 'COM3'
baud_rate = 115200
ser = serial.Serial(port, baudrate=baud_rate, timeout=1)

# Função de filtragem
def apply_filters(data, fs=1000):
    low_cutoff = 20
    b, a = butter(6, low_cutoff / (0.5 * fs), btype='low')
    low_passed = filtfilt(b, a, data)
    notch_freq = 75
    quality_factor = 45
    b, a = iirnotch(notch_freq / (0.5 * fs), quality_factor)
    notch_filtered = filtfilt(b, a, low_passed)
    return notch_filtered

# Configuração inicial do Dash
app = dash.Dash(__name__)
app.layout = html.Div([
    dcc.Graph(id='live-graph', animate=True),
    dcc.Interval(
        id='graph-update',
        interval=1000,  # in milliseconds
        n_intervals=0
    )
])

# Callback para atualizar o gráfico
@app.callback(
    Output('live-graph', 'figure'),
    [Input('graph-update', 'n_intervals')]
)
def update_graph_scatter(n):
    data = []
    while len(data) < 200:
        if ser.in_waiting:
            line = ser.readline().decode().strip()
            try:
                value = float(line)
                data.append(value)
            except ValueError:
                continue
    filtered_data = apply_filters(np.array(data))
    X = list(range(len(filtered_data)))
    
    data = go.Scatter(
        x=list(X),
        y=filtered_data,
        name='Scatter',
        mode= 'lines+markers'
    )

    return {'data': [data], 'layout' : go.Layout(xaxis=dict(range=[min(X), max(X)]), yaxis=dict(range=[min(filtered_data), max(filtered_data)]))}

if __name__ == '__main__':
    app.run_server(debug=True)
pip install dash
pip install plotly
pip install numpy
pip install scipy
pip install pyserial
